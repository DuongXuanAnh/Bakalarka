{
  "global": {
    "fillAllAttributes": "Fill all attributes",
    "mixDependenciesRandomly": "Mix randomly",
    "attributeClosure": "attribute closure",
    "reverseAttributes": "Reverse attributes"
  },

  "App": {
    "addAttributeFirst": "Please add attributes first!"
  },

  "navBar": {
    "nav-title-addAttribute": "Add Attributes",
    "nav-title-addDependencies": "Add Dependencies",
    "nav-title-problem": "Problems"
  },

  "content-attribute": {
    "h1-main-title": "DESIGN OF RELATIONAL SCHEMAS",
    "btn_loadFromBD": "Load Example from Database",
    "btn_loadFromComputer": "Upload Saved File",
    "label_addAttributes": "Add Attributes to Schema",
    "input_placeholder_newAttribute": "new attribute...",
    "msg_noAttributes": "Your schema will be generated here after adding new attributes or uploading a file",
    "list_attributes": "List of Attributes:",
    "schema_title": "Schema",
    "schema_placeholder": "You will see the schema here",
    "btn_setDependencies": "Set Dependencies →",
    "alert_attributeExists": "This attribute has already been added.",
    "alert_maxAttributes": "You can add a maximum of 15 attributes.",
    "select_exampleDatabase": "Select an Example from the Database",
    "input_placeholder_exampleNames": "Names of examples...",
    "btn_deleteExample": "Delete Example",
    "dialog_deleteExample": "Deleting an Example",
    "input_placeholder_adminPassword": "Administrator's Password",
    "alert_invalidPassword": "Invalid Password",
    "alert_exampleDeleted": "The example was successfully deleted!",
    "alert_fileFormat_wrong": "The file must be a txt file and have this format: \nAttributes: [attribute1, attribute2, ...] \nDependencies: [{left: [attribute1, attribute2, ...], right: [attribute1, attribute2, ...]}, ...]",
    "alert_fileFormat_correct": "The file was successfully uploaded!",
    "alert_fileFormat_title": "File format error",
    "alert_fileFormat_correct_text": "Attributes and dependencies were successfully imported."
  },

  "content-dependencies": {
    "addRelation": "Add Dependency",
    "option_addAttribute": "Add Attribute",
    "btn_removeDependency": "Remove",
    "btn_backToInputAttributes": "← Return to Input Attributes",
    "btn_solveProblems": "Solve Problems →",
    "undefined": "Undefined",
    "leftSide": "Left side",
    "rightSide": "Right side",
    "delete": "Delete",
    "saveChanges": "Save Changes",
    "updateDependency": "Update Dependency",
    "unfinishedDependency": "There is unfinished dependency",
    "needSelectBothSides": "You need to select attributes on both sides",
    "back": "Cancel",
    "fillAllAttributes": "Fill all attributes"
  },

  "content-problems": {
    "title_problem": "Our Problem",
    "title_schema": "Schema",
    "schema_placeholder": "You will see the schema here",
    "title_dependencies": "Dependencies:",
    "saveExample": "Save this Example",
    "saveToServer": "Save to Server",
    "attributeClosure": "Attribute Closure",
    "redundantAttribute": "Redundant Attributes",
    "redundantDependency": "Redundant Dependency",
    "minimalCover": "Minimal Cover",
    "firstKey": "First Key",
    "allKeys": "All Keys",
    "derivability": "Derivability",
    "normalForm": "Normal Form",
    "decomposition": "Decomposition",
    "synthesis": "Synthesis",
    "warning_title": "Warning!",
    "warning_text": "This name already exists. Please choose a different name.",
    "alert_saveSuccess": "The example was successfully saved!",
    "alert_invalidPassword": "Invalid Password",
    "input_placeholder_databaseName": "Database Name...",
    "input_placeholder_adminPassword": "Administrator's Password",
    "invalidDocumentName": "Invalid name",
    "alert_invalidDocumentName": "The name must not contain special characters."
  },

  "problem-attributeClosure": {
    "schema": "Schema",
    "youWillSeeTheSchemaHere": "Here you will see the schema",
    "dependencies": "Dependencies:",
    "selectAttributes": "Select attributes",
    "addAttribute": "Add attribute",
    "showAttributeClosure": "Show attribute closure",
    "practiceAttributeClosure": "Practice attribute closure",
    "attributeClosure": "Attribute closure",
    "yourOpinionOnAttributeClosure": "Attribute closure according to your opinion",
    "checkTheResult": "Check the result",
    "showStepByStepProcedure": "Show the step-by-step procedure",
    "showNextStep": "Show the next step",
    "showTheWholeProcedure": "Show the entire procedure",
    "congratulations": "Congratulations!",
    "yourAnswerIsCorrect": "The answer is correct",
    "unfortunately": "Unfortunately",
    "yourAnswerIsIncorrect": "The answer is incorrect",
    "close": "Close",
    "selectAtLeastOneAttribute": "Select at least one attribute"
  },

  "problem-redundantAttribute": {
    "redundantAttributes": "Redundant attributes",
    "noRedundantAttributes": "No redundant attributes",
    "resultTitle": "Result",
    "choosenAttributesAreRedundant": "Chosen attributes are redundant",
    "choosenAttributesAreNotRedundant": "Chosen attributes are not redundant",
    "schema": "Schema",
    "youWillSeeTheSchemaHere": "You will see the schema here",
    "dependencies": "Dependencies:",
    "inputDependency": "Enter dependency",
    "addAttribute": "Add attribute",
    "showRedundantAttributes": "Show redundant attributes",
    "practice": "Practice",
    "selectAttrsToCheckRedundancy": "Select attributes to check for redundancy",
    "checkSelectedAttributes": "Check selected attributes",
    "chooseAttributesBeforeCheckRedundancy": "Choose attributes before checking for redundancy",
    "explanation": "Explanation",
    "explanation-Step1-part1": "Step 1: Gradually remove the attributes on the left side in the left-to-right order and check if",
    "explanation-Step1-part2": "the remaining attributes contain all the attributes that are on the right side. (The order in which we remove the attributes on the left side can affect the result, so this order can be changed.)",
    "explanation-Step2": "Step 2: If the attribute closure does not contain all the attributes on the right side, we return the removed attribute.",
    "explanation-Step3": "Step 3: If the attribute closure contains all the attributes on the right side, it means that the attribute on the left side is unnecessary and redundant, so we discard it.",
    "explanation-Step4": "Step 4: We return to the first step and repeat this process until we have gone through all the attributes on the left side."
  },

  "problem-redundantDependency": {
    "title": "Select all redundant dependencies:",
    "dragDropHint": "You can move the dependencies!",
    "resultNotUnique": "The result may not be unique and depends on the order. Here is shown just one option for demonstration.",
    "understandButton": "I understand",
    "congratulations": "Congratulations!",
    "correctSelection": "You have correctly selected all redundant dependencies.",
    "tryAgain": "Unfortunately!",
    "wrongSelection": "The result is incorrect. Try again.",
    "closeButton": "Close",
    "checkResultButton": "Check result",
    "showResultButton": "Show result",
    "reverseDependenciesButton": "Reverse dependencies",
    "explanation": "Explanation",
    "explanation-Step1": "Step 1: We will iterate from top to bottom and gradually try to remove the dependency. (The order in which we remove the dependencies can affect the result, so the order of the dependencies can be changed.)",
    "step2-part1": "Step 2: We will create ",
    "step2-part2": " from the left side of the dependency that we just removed, using the remaining not discarded dependencies.",
    "explanation-Step3": "Step 3: If the attribute closure contains the attributes on the right side, the dependency is redundant, and we can definitely discard it.",
    "explanation-Step4": "Step 4: If the attribute closure does not contain the attributes on the right side, the dependency is not redundant, and we must return it back.",
    "noRedundantDependencies": "There are no redundant dependencies"
  },

  "problem-minimalCover": {
    "finalResultTitle": "Minimal Cover",
    "finalResultNote": "(The result may not be unique and depends on the order of selection of dependencies. Try shuffling the dependencies in the first step in 'How to achieve the result'. Our program checks from top to bottom.)",
    "processTitle": "How to achieve the result:",
    "step1Title": "Step 1: Rewrite the dependencies to have only one attribute on the right side. We obtain:",
    "step1Note": "(Here you can move the dependencies.)",
    "step2Title": "Step 2: Remove trivial dependencies. We obtain:",
    "step2Note": "(Trivial dependencies are those where the attributes on the right side are a subset of the left side)",
    "step3Title": "Step 3: Remove redundant attributes on the left side. We obtain:",
    "step4Title": "Step 4: Remove redundant dependencies. We obtain:",
    "reverseDependenciesButton": "Reverse Dependencies",
    "showStepByStepButton": "Show step by step",
    "practiceNextStepButton": "Practice the next step",
    "showAllStepsButton": "Show all steps",
    "modalTitle": {
      "removeTrivialFDs": "Removing Trivial Dependencies",
      "removeRedundantAttributes": "Removing Redundant Attributes on the Left Side",
      "removeRedundantFDs": "Removing Redundant Dependencies"
    },
    "modalNote": {
      "selectTrivialFDs": "Select all trivial dependencies and confirm the answer (If you believe there are none, just confirm the answer)",
      "markRedundantAttributes": "Mark all redundant attributes and confirm the answer (you believe there are none, just confirm the answer)",
      "selectRedundantFDs": "Select all redundant dependencies (you believe there are none, just confirm the answer)"
    },
    "modalButtonConfirm": "Confirm the answer",
    "successAlertTitle": "Correct!",
    "successAlertText": "Continue to the next step.",
    "errorAlertTitle": "Wrong!",
    "errorAlertText": "Try again.",
    "continue": "Continue",
    "close": "Close"
  },

  "problem-firstKey": {
    "attributesListTitle": "List of Attributes:",
    "firstKeyTitle": "First Key: ",
    "showStepByStepButton": "Show step by step",
    "nextStepButton": "Next Step",
    "practiceNextStepButton": "Practice the next step",
    "showAllStepsButton": "Show all steps",
    "successAlertTitle": "Correct!",
    "successAlertText": "Your answer is correct.",
    "errorAlertTitle": "Wrong!",
    "errorAlertText": "The answer is incorrect, please try again. Separate attributes with a comma. For example: a,b,c",
    "closurePromptTitle": "The attribute closure {{closureAssignment}} is:",
    "closurePromptPlaceholder": "Write the attribute closure for {{closureAssignment}}"
  },

  "problem-allKeys": {
    "firstKeyIs": "The first key is",
    "writeFirstKeyHere": "Write the first key here...",
    "successAlertTitle": "Correct!",
    "errorAlertTitle": "Error!",
    "successAlertText": "Your answer is correct.",
    "errorAlertText": "The answer is incorrect, please try again.",
    "canChooseOnlyOneDependency": "You can choose only one dependency.",
    "allKeysTitle": "All keys:",
    "showStepByStep": "Show step by step",
    "nextStep": "Next step",
    "tryNextStep": "Try the next step",
    "showAllSteps": "Show all steps",
    "chooseDependenciesAccordingConditions": "Choose the dependency that meets our condition",
    "modalButtonConfirm": "Confirm the answer"
  },

  "problem-normalForm": {
    "chooseAtleastOneAttribute": "Choose at least one attribute",
    "schema": "Schema",
    "youWillSeeTheSchemaHere": "You will see the schema here",
    "dependencies": "Dependencies:",
    "selectAttributes": "Select attributes",
    "addAttribute": "Add attribute",
    "showInfoSelectedTable": "Show information for selected table",
    "result": "Result",
    "normalForm": "Normal form:",
    "candidateKeys": "Candidate keys",
    "howToGetCandidateKeys": "How to obtain candidate keys?",
    "faultyDependency": "Unwanted dependencies",
    "dependencies-simplifyFplus": "Dependencies: (Simplified F<0>+</0>)",
    "howToReachSimpleF": "How to achieve simplified F<0>+</0>?",
    "violates": "violates "
  },

  "problem-decomposition": {
    "chooseTheAnswerPlease": "Please, select the answer!",
    "correct": "Correct!",
    "incorrect": "Incorrect!",
    "lostDependencies": "FDs not preserved:",
    "detail": "Detail",
    "noLostDependencies": "None",
    "practiceMode": "Practice mode:",
    "showRandomDecomposition": "Show random decomposition",
    "nodeDetail": "Relation detail",
    "attributes": "Attributes: ",
    "keys": "Keys: ",
    "normalForm": "Normal form: ",
    "dependencies": "Dependencies: ",
    "unwantedDependencies": "Unwanted dependencies: ",
    "moreWayHowToDecomposite": "Decompose according to LS → LS<0>+</0> \\ LS",
    "check": "Check",
    "howToIdentifyNormalForm": "How to achieve normal form?",
    "rewrittenDependenciesRHS": "Rewritten dependencies to have one attribute on the right-hand side:",
    "howToIdentifyFplus": "How to achieve simplified F<0>+</0>?",
    "violates": "violates",
    "checkChosenDependencies": "Check chosen dependencies",
    "showTablesAfterDecomposition": "Show tables after decomposition",
    "insertYourDependency": "Insert dependency",
    "tablesAfterDecomposition": "Tables after decomposition",
    "customeNode": {
      "keys": "Keys: ",
      "isSubsetOf": "Subset of: "
    }
  },

  "problem-synthesis": {
    "candidateKeys": "Candidate Keys",
    "allKeys": "All Keys",
    "minimalCover": "Minimal Cover",
    "minimalCoverAfterMerge": "Minimal Cover After Adjustment:",
    "explainText1": "From the minimal cover, we create tables. For each rule, we can create one table. This means we get the following:",
    "note1": "Here you can change the order of dependencies to get a different minimal cover. Changes will be seen on the right.",
    "table": "Relation",
    "keys": "Keys",
    "reverseDependencies": "Reverse Dependencies",
    "noteText_originKeyNotContained": "Since no table contains any original key after the synthesis, we need to add a separate table that contains one of the original keys.",
    "unnecessaryTableSubet": "Table R{{index1}} is unnecessary because it is a subset of table R{{index2}}",
    "tableDetail": "Table detail",
    "key": "Key",
    "dependencies": "Dependencies",
    "normalForm": "Normal form",
    "violates": "violates",
    "TablesAreMergedTitle": "Relations Merged",
    "TablesAreMergedSuccessfully": "Relations were successfully merged",
    "CanNotMerge": "Cannot Merge",
    "CanNotMerge-reason1": "because the resulting relation would be in {{normalForm}} NF",
    "CanNotMerge-reason2": "because one is not a subset of the other, nor do they have identical or functionally equivalent keys"
  },

  "problem-derivability": {
    "dependencyIsDerivable": "Dependency is derivable",
    "dependencyIsNotDerivable": "Dependency is not derivable",
    "schema": "Schema",
    "youWillSeeTheSchemaHere": "You will see the schema here",
    "dependencies": "Dependencies:",
    "checkIfDependencyIsDerivable": "Check if dependency is derivable",
    "insertTheDependency": "Insert the dependency",
    "addAttribute": "Add attribute",
    "checkDerivability": "Check derivability",
    "dependenciesFromSelectedAttributes": "Functional dependencies that can be applied to the selected attributes",
    "chooseAttributes": "Choose attributes",
    "showSimplifyFplus": "Show simplified F<0>+</0>",
    "simplifyFplus": "Simplified F<0>+</0>",
    "step1": "Step 1: We create a set of all subsets of the attribute set that we have selected.",
    "step1Note": "(Altogether there are 2<0>number of attributes</0>-1 = 2<1>{{attributesAreaFplusLength}}</1>-1)",
    "step2": "Step 2: For each subset, we write an attribute closure.",
    "step3": "Step 3: Remove trivial dependencies, trivial attributes on the right-hand side, and attributes that do not belong to the list of selected attributes.",
    "step3_Note1": "Trivial dependencies are dependencies where identical attributes are on both sides (E.g., a→a, a,b→a,b).",
    "step3_Note2": "Trivial attributes on the right side are attributes that are also on the left side.",
    "step3_Note3": "(E.g., s,j,c,q → s,j,c,q,d,p,v), so s,j,c,q are trivial on the right side.",
    "step4": "Step 4: We remove redundant attributes on the left side",
    "step5": "Step 5: We unite dependencies with the same right side, thereby obtaining a simplified F<0>+</0>",
    "explainFplusResult": "Explanation of the F<0>+</0> result",
    "nextStep": "Next step",
    "selectAttributesBeforeCheck": "Select at least one attribute",
    "selectAttributesInBothSides": "Select attributes in both sides"
  },

  "attributeClosure": {
    "startWithAttributes": "Starting with attributes: {{attributes}}",
    "aimToFindClosure": "The goal is to find a closure for these attributes.",
    "currentClosure": "Current closure: {{closure}}",
    "examiningDependency": "Examining functional dependency: {{dependency}}",
    "addingToClosure": "The left side of the dependency is a subset of the closure and the right side is not, adding the right side to the closure.",
    "allAttrInClosure": "Since we already have all the attributes on the right side, we can stop here.",
    "newClosure": "New closure: {{closure}}",
    "noExtension": "This dependency does not lead to an extension of the closure.",
    "finalClosure": "Final closure of attributes: {{closure}}"
  },

  "firstKey": {
    "introduction": "To find the first key, we will start with a dependency where all attributes are on the left side, so we have:",
    "initialKeyToSchema": "{{candidateKey}} → {{schema}}",
    "tryToRemoveAttribute": "We will try to remove '{{attr}}'",
    "lookAtAttributeClosure": "Let's look at the attribute closure#^_^#",
    "attributeClosureResult": "({{potentialKey}})+ = {{closure}}",
    "attributeRedundant": "⇒ 'Atribute {{attr}}' is redundant, we can remove it, so we have",
    "attributeNotRedundant": "⇒ 'Atribute {{attr}}' is not redundant, so we have to keep it, so we still have",
    "finalFirstKey": "⇒ We obtain the first key: {{candidateKey}}"
  },

  "allKeys": {
    "removeTrivialAttributes": "Remove trivial attributes on the right-hand side, those that are included in the left-hand side",
    "removeTrivialAttributesResult": "Our dependencies will be: F = {{dependencies}}",
    "findFirstKeyTitle": "Find the first key (This first key may not be the only one, it depends on the order in which we removed the attributes.)",
    "firstKey": "Our first key is {{N}}#^_^#chooseFirstKey",
    "initializeKeysArray": "Create an array of all found keys (this array will contain the final result in the end), so far it will only contain the first key {{N}}",
    "keysArray": "Array of found keys: [ {{Keys}} ]",
    "initializeQueue": "Create a queue of keys and add the first key {{N}} to it",
    "queueContent": "Key queue contains: ({{Q}})",
    "checkDependencies": "Take the key K = {{key}} from the queue (in which [ {{keysQueue}} ] remains) and sequentially look at the dependencies X → Y in F from top to bottom to see if K ∩ Y ≠ ∅ and X ⊈ K.",
    "dependencyOffer": "Dependency offered: {{dependency}}#^_^#dependencyOffer",
    "reasonForNewKey": "Because {{K}} ∩ {{Y}} ≠ ∅ && {{X}} ⊈ {{K2}}",
    "potentialNewKey": "Potential new (super)key is (K ∪ X) \\ Y, which is: [({{K}} ∪ {{X}}) \\ {{Y}}] = {{newPossibleKey}}",
    "potentialNewKeyWhenDependency": "Because {{newPossibleKey}} is a (super)key, the rule is: {{newPossibleKey2}} → {{A}}",
    "reducePotentialKey": "Reduce the potential new (super)key (Remove redundant attributes on the left-hand side)",
    "finalNewKey": "Get {{newKey}}, which is a potential new key",
    "addNewKeyToArray": "Because we don't have this key in the array, we'll add {{newKey}} to the key array and get: [{{Keys}}]",
    "keyAlreadyExists": "Let's look in the key array. If it's not there, add it.",
    "finalAllKeys": "So all the keys are: {{Keys}}",
    "addNewKeyToQueue": "Add the new key {{newKey}} to the key queue and get: [{{Q}}]",
    "notFoundLegitDependency": "Because no dependency was found and keys queue is empty, we can finish and the key array contains the final answer.#^_^#dependencyOffer",
    "keyAlreadyInArray": "The key {{newKey}} is already in the key array, so we don't need to add it.",
    "keysQueueEmpty": "The queue of keys is empty, so we can finish, and the array of keys contains the final answer."
  },

  "ownDecomposition": {
    "addAttribute": "Add attribute",
    "decompose": "Decompose",
    "decomposeManually": "Decompose manually",
    "needChooseAttributes": "It is necessary to select at least one attribute on each side of the dependency.",
    "rightSideCantContainLeftAttr": "The right side must not contain attributes from the left side.",
    "giveTableContainAllAttr": "The left sub-relation would contain all the attributes of the decomposed relation.",
    "error": "Error",
    "rightSubRelation": "Right sub-relation",
    "leftSubRelation": "Left sub-relation",
    "leftSideNotCorrect": "The left sub-relation must represent the selected dependency and contain exactly all its attributes.",
    "rightSideNotCorrect": "The right sub-relation must contain all the attributes of the decomposed relation without those on the right side of the dependency.",
    "dependencyNotDerivable": "The specified dependency is not derivable in the decomposed relation",
    "needAtLeastOneAttr": "It is necessary to select at least one attribute for all fields.",
    "leftSideCanNotBeSuperKey": "The left side of FD is a (super)key, the dependency does not violate any normal form.",
    "close": "Close",
    "stillDecompose": "Decompose anyway",
    "doNotDecompose": "Revoke relation's decomposition",
    "decomposeRandomlyNode": "Decompose node randomly",
    "decomposeRandomlySubtree": "Decompose subtree randomly"
  },

  "mergeTablesAfterDecompose": {
    "isSubsetOf": "Subset of {{table}}",
    "addRelation": "Add"
  }
}
